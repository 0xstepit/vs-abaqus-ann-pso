"""
Author: Stefano Francesco Pitton

Mail: stefanofrancesco.pitton@polimi.it

Created: 26/03/2020

Description:
------------
"""
import numpy as np
import pandas as pd
import os

flag_bck = True
flag_stiff = True
flag_axial = False
flag_torsion = True
angles_func = 'harmlin'
load_case = 'torsion'
param = 2
folder_ss = 'symmetric_balanced'

directory = '../dataset/' + load_case + '/' + folder_ss + '/' + str(param) + 'x/' + angles_func + '/'
model_info = pd.read_csv(directory + 'model_info.csv', sep=",")
sets = [i.lower() for i in ['Train', 'Val', 'Test'] if i in model_info.columns]
# The annoying question of x.value[..] is due to series nature of the dataframe
h = int(model_info['Height'].values)
r = int(model_info['Radius'].values)
mesh_x = int(model_info['MeshSize'].values)
# h = 300
# r = 70
# mesh_x = 100
plies = int(model_info['Plies'].values)
eff_plies = int(model_info['EffectivePlies'].values)
symmetric = model_info['Symmetric'].values[0]
balanced = model_info['Balanced'].values[0]
t = 0.181

p = 2 * np.pi * r
mesh_yz = p / round(p / mesh_x)
n_x = int(h / mesh_x + 1)
n_yz = int(p / mesh_yz)
tot_nodes = n_x * n_yz
plot = False

x = np.linspace(0, h, n_x)
theta = np.arange(0, 2 * np.pi, 2 * np.pi / n_yz)
# theta = np.linspace(0, 2 * np.pi, n_yz) #last node coincide with first
y = r * np.cos(theta)
z = r * np.sin(theta)

coord_x = np.zeros(n_yz)
coord_y = y
coord_z = z
for v_elem in range(1, n_x):
    coord_x = np.append(coord_x, np.ones(n_yz) * x[v_elem])
    coord_y = np.append(coord_y, y)
    coord_z = np.append(coord_z, z)

nodes = {}
for n in range(0, tot_nodes):
    name = 'Node' + str(n + 1)
    nodes[name] = (round(coord_x[n], 6), round(coord_y[n], 6), round(coord_z[n], 6))

ref_nodes = {'Load': (h, 0, 0), 'Constraint': (0, 0, 0)}

set_nodes ={'LoadNodes': [i for i in range(n_x * n_yz - n_yz + 1, n_x * n_yz + 1)],
            'ConstraintNodes': [i for i in range(1, n_yz + 1)]}

elements = {}
foo = 1
for n_v in range(0, n_x - 1):
    for n_h in range(0, n_yz - 1):
        name = 'Element' + str(foo)
        foo += 1
        n1 = n_v * n_yz + n_h + 1
        n2 = n1 + 1
        n3 = n2 + n_yz
        n4 = n1 + n_yz
        elements[name] = (n1, n2, n3, n4)
    mid1 = n2 - n_h - 1
    mid2 = n3 - n_h - 1
    elements['Element' + str(foo)] = (n2, mid1, mid2, n3)
    foo += 1
tot_elems = foo - 1

# Create the folder in which store the abaqus analysis
folder = 'abaqus_analysis'
try:
    if not os.path.isdir(directory + folder):
        os.makedirs(directory + folder)
except OSError:
    print('Error: Creating directory. ' + directory + folder)

if flag_bck:
    for curr_set in sets:

        try:
            if not os.path.isdir(directory + folder + '/' + curr_set):
                os.makedirs(directory + folder + '/' + curr_set)
        except OSError:
            print('Error: Creating directory. ' + directory + folder + '/' + curr_set)

        tht_col = ['Theta' + str(j) for j in range(1, n_x)]  # elems in x = nodes in x -1
        new_dir = directory + curr_set + '/'
        angles = {}
        for ply in range(1, eff_plies + 1):
            ang = pd.read_csv(new_dir + 'theta' + str(ply) + '.csv', names=tht_col, sep=",", skiprows=1)
            angles.update({'Ply' + str(ply): ang.values})

        if curr_set == 'train':
            smpls = int(model_info['Train'].values)
        elif curr_set == 'test':
            smpls = int(model_info['Test'].values)
        elif curr_set == 'values':
            smpls = int(model_info['Val'].values)

        for s in range(1, smpls + 1):
            curr_sample = directory + folder + '/' + curr_set + '/sample' + str(s)
            try:
                if not os.path.isdir(curr_sample):
                    os.makedirs(curr_sample)
            except OSError:
                print('Error: Creating directory. ' + curr_sample)

            if flag_axial:
                heading = 'Analysis of a variable stiffness cylindrical shell in axial compression'
            if flag_torsion:
                heading = 'Analysis of a variable stiffness cylindrical shell in torsion'

            job = 'Buckling analysis'
            model = 'Variable stiffness cylindrical shell'

            f = open(directory + folder + '/' + curr_set + '/sample' + str(s) + '/bck_sample' + str(s) + '.inp', "w+")
            f.write('*HEADING\n' + heading + '\n')
            f.write('** Job name: ' + job + '\n')
            # f.write('** Model name: ' + model + '\n')
            f.write('** Generated by: S.F. Pitton\n')

            f.write('**\n** PARTS\n**\n')
            part_name = 'Cylinder'
            f.write('*Part, name = ' + part_name + '\n')
            f.write('*End Part\n')

            f.write('**\n** ASSEMBLY\n**\n')
            assembly_name = 'Assembly_Cylinder'
            f.write('*Assembly, name = ' + assembly_name + '\n**\n')
            instance_name = 'Instance_Cylinder'
            f.write('*Instance, name = ' + instance_name + ', part = ' + part_name + '\n')

            f.write('**\n** MESH\n**\n')
            f.write('*Node\n')
            # f.write('*Node, nset = all\n')
            for ID_node in range(1, tot_nodes + 1):
                nx = nodes['Node' + str(ID_node)][0]
                ny = nodes['Node' + str(ID_node)][1]
                nz = nodes['Node' + str(ID_node)][2]
                f.write('%4.0f, %12.6f, %12.6f, %12.6f\n' % (ID_node, nx, ny, nz))

            f.write('**\n** ELEMENTS\n**\n')
            f.write('*Element, type=S4R\n')
            # f.write('*Element, type=S4R, elset = all\n')
            for ID_elem in range(1, tot_elems + 1):
                n1 = elements['Element' + str(ID_elem)][0]
                n2 = elements['Element' + str(ID_elem)][1]
                n3 = elements['Element' + str(ID_elem)][2]
                n4 = elements['Element' + str(ID_elem)][3]
                f.write('%4.0f, %4.0f, %4.0f, %4.0f, %4.0f\n' % (ID_elem, n1, n2, n3, n4))

            f.write('**\n** SETS OF ELEMENTS\n**\n')
            for e_set in range(0, n_x - 1):
                f.write('*Elset, elset = set' + str(e_set + 1) + ', GENERATE\n')
                e_start = 1 + e_set * n_yz
                e_end = n_yz + e_set * n_yz
                inc = 1
                f.write('%4.0f, %4.0f, %4.0f\n' % (e_start, e_end, inc))

            f.write('**\n** SECTION\n**\n')
            for j in range(1, n_x):
                if symmetric:
                    f.write('*Shell Section, elset = set' + str(j) + ', composite, layup = vs' + str(j) + ', symmetric\n')
                else:
                    f.write('*Shell Section, elset = set' + str(j) + ', composite, layup = vs' + str(j) + '\n')

                for i in range(0, eff_plies):
                    f.write('%1.4f, %d, AS4/8552, %4.2f, ply%d \n' % (t, 3, angles['Ply' + str(i + 1)][s - 1][j - 1], i + 1))

                    if balanced:
                            f.write('%1.4f, %d, AS4/8552, %4.2f, ply%d \n' %
                                    (t, 3, -angles['Ply' + str(i + 1)][s - 1][j - 1], i + eff_plies + 1))

            f.write('**\n*End Instance\n**\n')

            f.write('**\n*Node\n')
            foo = 1
            for key in ref_nodes.keys():
                nx = ref_nodes[key][0]
                ny = ref_nodes[key][1]
                nz = ref_nodes[key][2]
                f.write('%4.0f, %12.6f, %12.6f, %12.6f\n' % (tot_nodes + foo, nx, ny, nz))
                foo += 1

            f.write('**\n** SETS OF NODES\n**\n')
            for key in set_nodes.keys():
                f.write('*Nset, nset = ' + key + ', GENERATE, instance = ' + instance_name + '\n')
                n_start = set_nodes[key][0]
                n_end = set_nodes[key][-1]
                inc = 1
                f.write('%4.0f, %4.0f, %4.0f\n' % (n_start, n_end, inc))

            f.write('**\n** CONSTRAINTS\n**\n')
            foo = 1
            for key in set_nodes.keys():
                f.write('*Rigid Body, ref node = %4.0f,' % (tot_nodes + foo))
                f.write('tie nset = ' + key + '\n')
                foo += 1

            f.write('**\n*End Assembly\n')

            f.write('**\n** MATERIALS\n**\n')
            f.write('*Material, name = AS4/8552\n')
            f.write('*Elastic, type = LAMINA\n')
            f.write('%4.1f, %4.1f, %4.1f, %4.1f, %4.1f, %4.1f\n' % (141000., 10300.,   0.3, 4500., 4500., 3700.))

            f.write('**\n** ----------------------------------------------------------------\n')
            f.write('**\n** STEP\n**\n')
            f.write('*Step, name = "Buckling force step", nlgeom = NO, perturbation\n')
            f.write('Eigenvalues calculation \n')
            f.write('*Buckle\n')
            f.write('%d, , 600,\n' % 5)

            if flag_axial:
                f.write('**\n** BOUNDARY CONDITIONS\n**\n')
                f.write('** Name:Only x displacements free\n')
                f.write('*Boundary, op = NEW, load case = 1 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 2, 6))
                f.write('*Boundary, op = NEW, load case = 2 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 2, 6))
                f.write('** Name: Clamped edge\n')
                f.write('*Boundary, op = NEW, load case = 1 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 2, 1, 6))
                f.write('*Boundary, op = NEW, load case = 2 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 2, 1, 6))

                f.write('**\n** LOADS\n**\n')
                f.write('** Name: Concentrated force \n')
                f.write('*Cload \n')
                f.write('%d, %d, %2.2f\n' % (tot_nodes + 1, 1, -1.))

            if flag_torsion:
                f.write('**\n** BOUNDARY CONDITIONS\n**\n')
                f.write('** Name: Constraint y and z displacements\n')
                f.write('*Boundary, op = NEW, load case = 1 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 2, 3))
                f.write('*Boundary, op = NEW, load case = 2 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 2, 3))
                f.write('** Name: Constraint rotations around y and z\n')
                f.write('*Boundary, op = NEW, load case = 1 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 5, 6))
                f.write('*Boundary, op = NEW, load case = 2 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 5, 6))
                f.write('** Name: Clamped edge\n')
                f.write('*Boundary, op = NEW, load case = 1 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 2, 1, 6))
                f.write('*Boundary, op = NEW, load case = 2 \n')
                f.write('%d, %d, %d\n' % (tot_nodes + 2, 1, 6))

                f.write('**\n** LOADS\n**\n')
                f.write('** Name: Concentrated torque\n')
                f.write('*Cload \n')
                f.write('%d, %d, %2.2f\n' % (tot_nodes + 1, 4, -1.))

            f.write('**\n** OUTPUT REQUESTS\n**\n')
            f.write('*Restart, write, frequency = 0\n')
            f.write('**\n** FIELD OUTPUT\n**\n')
            f.write('*Output, field\n')
            f.write('*Node Output\n')
            f.write('RF, U\n')
            f.write('*Element Output, directions = YES\n')
            f.write('E, S\n')
            f.write('**\n** FIELD OUTPUT\n**\n')
            f.write('*Output, field, variable = PRESELECT\n')
            f.write('*End Step')

            f.close()

if flag_stiff:
    for curr_set in sets:

        try:
            if not os.path.isdir(directory + folder + '/' + curr_set):
                os.makedirs(directory + folder + '/' + curr_set)
        except OSError:
            print('Error: Creating directory. ' + directory + folder + '/' + curr_set)

        tht_col = ['Theta' + str(j) for j in range(1, n_x)]  # elems in x = nodes in x -1
        new_dir = directory + curr_set + '/'
        angles = {}
        for ply in range(1, eff_plies + 1):
            ang = pd.read_csv(new_dir + 'theta' + str(ply) + '.csv', names=tht_col, sep=",", skiprows=1)
            angles.update({'Ply' + str(ply): ang.values})

        if curr_set == 'train':
            smpls = int(model_info['Train'].values)
        elif curr_set == 'test':
            smpls = int(model_info['Test'].values)
        elif curr_set == 'values':
            smpls = int(model_info['Val'].values)

        for s in range(1, smpls + 1):
            curr_sample = directory + folder + '/' + curr_set + '/sample' + str(s)
            try:
                if not os.path.isdir(curr_sample):
                    os.makedirs(curr_sample)
            except OSError:
                print('Error: Creating directory. ' + curr_sample)

            if flag_axial:
                heading = 'Analysis of a variable stiffness cylindrical shell in axial compression'
            if flag_torsion:
                heading = 'Analysis of a variable stiffness cylindrical shell in torsion'

            job = 'Stiffness calculation analysis'
            model = 'Variable stiffness cylindrical shell'

            f = open(directory + folder + '/' + curr_set + '/sample' + str(s) + '/stiff_sample' + str(s) + '.inp', "w+")
            f.write('*HEADING\n' + heading + '\n')
            f.write('** Job name: ' + job + '\n')
            # f.write('** Model name: ' + model + '\n')
            f.write('** Generated by: S.F. Pitton\n')

            f.write('**\n** PARTS\n**\n')
            part_name = 'Cylinder'
            f.write('*Part, name = ' + part_name + '\n')
            f.write('*End Part\n')

            f.write('**\n** ASSEMBLY\n**\n')
            assembly_name = 'Assembly_Cylinder'
            f.write('*Assembly, name = ' + assembly_name + '\n**\n')
            instance_name = 'Instance_Cylinder'
            f.write('*Instance, name = ' + instance_name + ', part = ' + part_name + '\n')

            f.write('**\n** MESH\n**\n')
            f.write('*Node\n')
            # f.write('*Node, nset = all\n')
            for ID_node in range(1, tot_nodes + 1):
                nx = nodes['Node' + str(ID_node)][0]
                ny = nodes['Node' + str(ID_node)][1]
                nz = nodes['Node' + str(ID_node)][2]
                f.write('%4.0f, %12.6f, %12.6f, %12.6f\n' % (ID_node, nx, ny, nz))

            f.write('**\n** ELEMENTS\n**\n')
            f.write('*Element, type=S4R\n')
            # f.write('*Element, type=S4R, elset = all\n')
            for ID_elem in range(1, tot_elems + 1):
                n1 = elements['Element' + str(ID_elem)][0]
                n2 = elements['Element' + str(ID_elem)][1]
                n3 = elements['Element' + str(ID_elem)][2]
                n4 = elements['Element' + str(ID_elem)][3]
                f.write('%4.0f, %4.0f, %4.0f, %4.0f, %4.0f\n' % (ID_elem, n1, n2, n3, n4))

            f.write('**\n** SETS OF ELEMENTS\n**\n')
            for e_set in range(0, n_x - 1):
                f.write('*Elset, elset = set' + str(e_set + 1) + ', GENERATE\n')
                e_start = 1 + e_set * n_yz
                e_end = n_yz + e_set * n_yz
                inc = 1
                f.write('%4.0f, %4.0f, %4.0f\n' % (e_start, e_end, inc))

            f.write('**\n** SECTION\n**\n')
            for j in range(1, n_x):
                if symmetric:
                    f.write(
                        '*Shell Section, elset = set' + str(j) + ', composite, layup = vs' + str(j) + ', symmetric\n'
                    )
                else:
                    f.write('*Shell Section, elset = set' + str(j) + ', composite, layup = vs' + str(j) + '\n')

                for i in range(0, eff_plies):
                    f.write(
                        '%1.4f, %d, AS4/8552, %4.2f, ply%d \n' % (t, 3, angles['Ply' + str(i + 1)][s - 1][j - 1], i + 1)
                    )

                if balanced:
                    for i in range(0, eff_plies):
                        f.write('%1.4f, %d, AS4/8552, %4.2f, ply%d \n' %
                                (t, 3, -angles['Ply' + str(i + 1)][s - 1][j - 1], i + eff_plies + 1))

            f.write('**\n*End Instance\n**\n')

            f.write('**\n*Node\n')
            foo = 1
            for key in ref_nodes.keys():
                nx = ref_nodes[key][0]
                ny = ref_nodes[key][1]
                nz = ref_nodes[key][2]
                f.write('%4.0f, %12.6f, %12.6f, %12.6f\n' % (tot_nodes + foo, nx, ny, nz))
                foo += 1

            f.write('**\n** SETS OF NODES\n**\n')
            for key in set_nodes.keys():
                f.write('*Nset, nset = ' + key + ', GENERATE, instance = ' + instance_name + '\n')
                n_start = set_nodes[key][0]
                n_end = set_nodes[key][-1]
                inc = 1
                f.write('%4.0f, %4.0f, %4.0f\n' % (n_start, n_end, inc))

            f.write('**\n** CONSTRAINTS\n**\n')
            foo = 1
            for key in set_nodes.keys():
                f.write('*Rigid Body, ref node = %4.0f,' % (tot_nodes + foo))
                f.write('tie nset = ' + key + '\n')
                foo += 1

            f.write('**\n*End Assembly\n')

            f.write('**\n** MATERIALS\n**\n')
            f.write('*Material, name = AS4/8552\n')
            f.write('*Elastic, type = LAMINA\n')
            f.write('%4.1f, %4.1f, %4.1f, %4.1f, %4.1f, %4.1f\n' % (141000., 10300., 0.3, 4500., 4500., 3700.))

            if flag_axial:
                f.write('**\n** BOUNDARY CONDITIONS\n**\n')
                f.write('** Name: Only x displacements free\n')
                f.write('*Boundary\n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 2, 6))
                f.write('** Name: Clamped edge\n')
                f.write('*Boundary\n')
                f.write('%d, %d, %d\n' % (tot_nodes + 2, 1, 6))

            if flag_torsion:
                f.write('**\n** BOUNDARY CONDITIONS\n**\n')
                f.write('** Name: Only x displacements free\n')
                f.write('*Boundary\n')
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 2, 3))
                f.write('%d, %d, %d\n' % (tot_nodes + 1, 5, 6))
                f.write('** Name: Clamped edge\n')
                f.write('*Boundary\n')
                f.write('%d, %d, %d\n' % (tot_nodes + 2, 1, 6))

            f.write('**\n** ----------------------------------------------------------------\n')
            f.write('**\n** STEP\n**\n')
            f.write('*Step, name = "Linear static force step", nlgeom = YES\n')
            f.write('Linear static analysis \n')
            f.write('*Static\n')
            f.write('1., 1., 1e-05, 1.,\n')

            if flag_axial:
                f.write('**\n** LOADS\n**\n')
                f.write('** Name: Concentrated force \n')
                f.write('*Cload \n')
                f.write('%d, 1, -100000\n' % (tot_nodes + 1))

            if flag_torsion:
                f.write('**\n** LOADS\n**\n')
                f.write('** Name: Concentrated force \n')
                f.write('*Cload \n')
                f.write('%d, 4, 1000000\n' % (tot_nodes + 1))

            f.write('**\n** OUTPUT REQUESTS\n**\n')
            f.write('*Restart, write, frequency = 0\n')
            f.write('**\n** FIELD OUTPUT\n**\n')
            f.write('*Output, field\n')
            f.write('*Node Output\n')
            f.write('RF, U\n')
            f.write('*Element Output, directions = YES\n')
            f.write('E, S\n')
            f.write('**\n** FIELD OTPUT\n**\n')
            f.write('*Output, field, variable = PRESELECT\n')
            f.write('*End Step')

            f.close()

# WRITE THE .bat FILE TO EXECUTE ALL THE ANALYSIS
f = open('abaqus_analysis_launcher.bat', "w+")

f.write('cd ' + directory + 'abaqus_analysis \n')

for curr_set in sets:

    f.write('cd ' + curr_set + '\n')

    if curr_set == 'train':
        smpls = int(model_info['Train'].values)
    elif curr_set == 'test':
        smpls = int(model_info['Test'].values)
    elif curr_set == 'values':
        smpls = int(model_info['Val'].values)

    for s in range(1, smpls + 1):
        f.write('cd sample' + str(s) + '\n')
        f.write('call abaqus job=bck_sample' + str(s) + ' interactive\n')
        f.write('call abaqus job=stiff_sample' + str(s) + ' interactive\n')
        f.write('cd ..\n')

    f.write('cd ..\n')

f.close()

